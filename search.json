[{"title":"2023总结——读研第二年","path":"/2023/12/31/2023总结/","content":"这可能是我在博客上第一次写个人的年终总结吧。回想过去一年，自己的关键词是成长吧。 1. 雅思一把7.0 我今年考了雅思，我给自己每天记录了一个系列“雅思倒计时XX天”，考完那会我觉得作文写得还不错，但是口语发挥很烂，但是幸运的是最后到了7分一次通过。我不是凡尔赛，学英语的道路上基本是哑巴英语，而且我的英语成绩不算很好，考的最差的一次差点不及格，还被当时的英语老师给挖苦了。当时看很多英语阅读文章容易曲解意思，现在想想可能是单词掌握不够吧。但我从大四保研完就开始背单词，到考试那会也基本把所有的雅思单词背完了，再看雅思的文章词都认识也不需要硬猜了，可能难的就是里面的逻辑了。在备考雅思的过程中我觉得对自己的思维的提升很大，外国人和中国人的的思维不一样，中国人是线性思维，起承转合，按时间顺序依次铺开，但是外国人会先把结果拎出来，然后再加上一系列的从句来修饰。其次外国人有着更严密的逻辑，写东西讲东西强调句子和句子之间的联系，而不是东一下西一下。在备考的过程中，我的批判性思维也得到了加深吧。考完是6月24日，7月马不停蹄地去参加了人生第一次国际会议，用英文做了演讲，锤炼了制作PPT和演讲的能力，三亚这个城市还是很漂亮的，以后有机会还要去看看。 三亚演讲 三亚摩托艇 很有特色的棚子 潜水的装备 好大的椰子 2. 拿到了驾照本本 今年忙里偷闲边科研边学了驾照，练车的时候老是被嫌弃，说是所有人里面开得最差的那个，确实我的动手能力不算特别强，很多时候容易慌乱，比如挂挡挂得很用力，一度把推杆推得和皮套分离了（捂脸）。说来也幸运，考科二和科三的时候都有两次机会，我都是第二次过的，科一和科四理论就比较简单了，做题就好了。所以整个驾考下来我算是一遍过的，没有交补考的冤枉钱。 驾照到手了 3. 博客成长 我搭建这个博客原来想更新文章的，但是科研上老师实在催得太紧，而且我想在这个博客上写质量比较高的文章，但是一篇高质量的文章得投入不少的时间，这对正在读研的我可能还是会比较耗费精力的。所以我还是主要在CSDN上记录自己的学习日常，质量可能参差不齐，而且比较繁杂，但是当做一个云笔记本还是挺好的哈哈，至于这个博客也会更新的，但是可能要等真正有闲的时候了。在CSDN上今年更新了247篇文章吧，比去年又增加了近一倍，陆陆续续地有粉丝关注，博客的阅读量也快突破100w了。去年才84粉丝的，今年已经331个粉丝了。 CSDN博客记录 4. 阅读 今年大多数可能还是看的编程相关的书籍，除了年初看了小曦推荐的《众神世界》以及后来看的《斗罗大陆3龙王传说》，里面的主角也是一路成长其他还看了个人成长相关的《不要等到毕业以后》《梁永安阅读游历和爱情》，政治军事相关的《毛泽东选集-第一卷》，领悟了如何更深刻地看待问题吧。 微信读书 5. 编程和工作的方向 今年通过《C++ Primer》重新捡起了C++，把代码随想录一刷通过了，力扣现在是203题，已经开始二刷了，今年最该庆幸的是我找到了以后想要工作的方向，就是计算机图形学，它被誉为计算机最浪漫的三个学科之一（其他两个是操作系统和编译原理），既有数学物理在里面，又有编程，还是一个系统级的工程，有广度有深度，希望好好准备来年可以找到心仪的公司在这个方向深耕下去叭。 力扣刷题 6. 科研 最后说说科研叭，年初研一那会还想着好好学学专业知识，为科研打打基础，说不定以后读博呢，现在想想还是太天真的，我提升数学能力是潜移默化的，今年算是学完了古典微分几何、张量分析初步、李群和李代数以及凸优化初步，了解了一点点的实变函数和泛函分析以及变分法原理（只看了第一章这种程度）。这些都是课余自学的，学习的过程中更培养了自主查找资料学习的意识，但是没有应用理解可能不够深刻吧，不过来年要找工作了，数学的东西未来一年可能要放一放了。详细的总结可以看我的知乎回答： 2023年你的数学研究或学习有什么收获和感悟？ 我其实收集了很多资料，但是看完的不多，经典的好书还是有的，比如《Robot Dynamic Lecture Note》100多页的小册子。下图是我的文件夹，现在翻出来发现已经下载了好多资料： 整理的学习资料 然而尽管如此，科研上还是遇到了不少挫折，我也一度陷入读论文的漩涡中苦思冥想无果，文献的方法不work是时常发生的，而老师又只要求最后的结果不要求中间的细节，实验室又奉行单打独斗，一个人搞一个方向，老师少有提供方向指导而又催进度，老师还想劝我读博的，但是和兴趣相比我还是想去工业界探索吧。可能还是不喜欢这种工作氛围，毕竟不能得到持续地正反馈。最近在搞一个仿真，重新整理了一下思路，我原来Matlab使用的是面向过程编程，这次全部重写改为了面向对象编程，进行了拆解和细分，感觉思路清晰不少，而且用到了新学的哈希表、设计模式和深拷贝。但是工作量依旧很大，一部分模型已经work了，但是还不够，还需要实验进行验证。 7. 来年的展望 精进编程实践能力，夯实图形学的基础，找到心仪的工作。 继续总结复盘，撰写博客，构建自己的知识体系框架。 科研上早日把实验做完，产出论文专利成果达到毕业要求。","tags":["年终总结"]},{"title":"雅思备考资料总结记录","path":"/2023/06/25/雅思备考资料总结记录/","content":"出分啦，6.5 7.5 6.5 6.5，总分7分，原来以为还要二战哈哈哈，这个分再也不用再纠缠啦~如果要出国真的基本满足要求了！ 先说基础，高考英语134，大学四级587，大学六级506，背了一年单词，从大四到研一，测过词汇量为10000出头，其中雅思算是全部背完，测试用每日英语听力进行，测100多个词差不多很准了。 2023年6月24日首考雅思，也就是今天，自己复习了40天的雅思，记录一下看过的资料，时间比较紧，读完的书比较有限，写点自己的心得（不能保证我的观点适合所有人）。这次可能考得不好，后面可能还得反思继续提升薄弱的地方。 听力-Listening 《王陆听力语料库》。只刷了一遍，正确率80%吧，如果更加熟练可能考场上对词语更加敏感吧，但是练这个我感觉写一会就手酸了，特别是11章，语速上来，手写飞快，她说周六把3/4/5/11全部听完，我感觉自己没有那个毅力（捂脸），基本都是抽业余时间训练的（比如中午睡觉）。 何琼的网课。主要有以下几点好处，一是怎么画题目的关键词，二是怎么总结自己听力的错误，三是逻辑词的重要性，听的时候关注逻辑词，四是对各种题型都有一个分析。至于其他就靠自己平常多做多体会。 口语-Speaking 《顾家北词伙》。全部看完，试着练习了书里所有的口语，并且背了词伙，感觉顾家北老师口语也和作文一样强调论证逻辑，举例、解释、对比、结果，我的作文和口语很多也是使用了这个方法来扩展的，而且他里面的白搭观点也挺好，就是写得比较散，没有归纳概括，这点慎小嶷的我觉得压迫好一点。 《慎小嶷口语10天》。看了前面7章，后面三章分别是part 1,part 2, part 3，没有太多时间看了，最后就没看了，但是前面讲得挺好，挺实用的。配套的还有他的《口语高频短语速查手册》，排版很好看，都是地道的表达。 Cambly。可以在淘宝买账号（很便宜，每节课30分钟，平均下来一节课3块多）和歪果仁对练，我觉得还挺有帮助的，如果某个题你不会，你可以直接问歪果仁看他会怎么回答，我参考B站一个up主的视频一般都是这样开头：I would like this to be very student-centered, and I want to talk more. I will give you some questions, you ask them and I will anwser them; I Also would like you to correct me if I make any mistakes. And if I get stuck, please try to understand what I am trying to say and help me finish the sentence.然后你就可以把问题发给他了，全程以你为主，他来给你纠正。说完要注意总结复盘，Cambly一个好处就是你可以把对话的视频下载下来，可以回听记笔记记录错误，不过我在口语考前几天才发现这个好东西，虽然还是磕磕巴巴，但是思考观点有进步了，能够做扩展了，不得不说看了很多但是说不出来是很痛苦的，所以尽量提前准备口语呀！ B站up主&lt;刘黑眼圈子&gt;。哈哈她的无厘头口语回答瞬间粉了我，她是主张不背单词的（我觉得意思是不背答案不背套句）强调freestyle的，我虽然考场就是freestyle，但是经常卡壳，还是说得不熟练，但是她给了很多说的思路，比如描述事件、描述人，很实用，而且她的口音听起来好舒服呀，干货满满。我觉得有一点她说得很对，就是口语对话你要有交流感，背答案的话那换了其他你不熟悉的话题你怎么说话呢？ https://space.bilibili.com/19441507?spm_id_from=333.337.0.0https://space.bilibili.com/19441507?spm_id_from=333.337.0.0 阅读-Reading 《刘洪波阅读真经》。比较老的书了，感觉现在考的雅思不仅仅考的同义替换了，而是对文章的全面的理解。不过了解阅读的题型很有帮助。 B站up主&lt;迷胡去会阅读&gt;（小红书也有账号）。平行阅读法对阅读很有帮助，解决了长难句阅读的思路，抓主干，抓核心，采用PIE的思路，看完文章题目做完，考试时间来得及了。 https://space.bilibili.com/520705800?spm_id_from=333.337.0.0https://space.bilibili.com/520705800?spm_id_from=333.337.0.0 写作-Writing 《慎小嶷写作10天》。很清晰，全部看完，地道表达对今天的写作帮助很大，而且他的观点的思考也进行了概括，从12个方面思考问题很实用，我考场上就是这样思考的，包括经济、就业、环境、健康、科技、安全、效率、技能、乐趣、文化、权利、责任，我大作文估计花了30分钟就写完了，其中5分钟是思考观点时间。小作文也很好，你可以学到各种表达数据或者趋势的方式，然后范文也很地道，不难懂，抓核心数据多看几篇然后有意识模仿就好了。配套的还有他的《写作高频短语速查手册》，排版很好看，也都是地道的表达，如果来不及，就看前面说的《慎小嶷写作10天》，那都是精华，起码我考试知道核心课程是core subject，全面发展是well-rounded，知道地道的表达写得就很顺啦，顾家北的《词伙》也差不多这个道理，两本都可以进行背诵，挑选你喜欢的。 《刘洪波写作真经》。大作文的15句结构很多人推荐，但是我感觉比较单薄，有点模板化的意思，可能适合初学雅思的人，可能我比较喜欢灵活一点。小作文写得太少了，感觉参考性不大。 《顾家北手把手教你写作》。看了前面的改写，还是很有帮助的，纠正了很多以前的表达的错误，但是书比较长，大作文小作文都写得很地道，但是我感觉模仿不来，慎小嶷的感觉更好入门和模仿一点，看他的书做到清晰准确流畅就好了，不要用很多的大词。我按书里的题目写了两篇小作文，感觉有点崩溃，看着自己的表达和书里的表达感觉自己就是个小学生，太高级了短时间学不来（捂脸）。如果长时间备战的我觉得看老顾的吧，把书里所有范文过一遍，作文相信会提升一个档次的。","tags":["英语"],"categories":["英语"]},{"title":"《机器人控制系统和MATLAB Simulink仿真》笔记1-两关节机械臂PD控制（不考虑重力）","path":"/2023/04/05/《机器人控制系统和MATLAB-Simulink仿真》笔记1-两关节机械臂PD控制（不考虑重力）/","content":"前言 最近在看控制的东西，想动手实践一下，看到有书名曰《机器人控制系统和MATLAB simulink仿真》，于是学习一下做做记录，也丰富自己对控制和动力学的理解。 二关节机械臂的动力学推导 书上给出了不考虑重力的动力学公式为： Image 这里的p1p_1p1​、p2p_2p2​、p3p_3p3​、q1q_1q1​、q2q_2q2​都是什么东西？写得不清不楚的，不过推导动力学用拉格朗日是传统艺能了，我们就来推导一下。 不考虑重力、摩擦力和干扰，那我们就不用考虑系统的势能了。 Image 作为一个二关节机械臂，我们认为连杆的质量都集中在末端,旋转关节都在始端，两个旋转关节的旋转角度分别如图旋转θ1\\theta_1θ1​和θ2\\theta_2θ2​，我们取它们作为广义坐标。 从基座如图建立平面坐标系，我们可以写出每个连杆末端旋转副的位置.第一个连杆XXX方向和YYY方向的坐标为： x1=l1cos⁡θ1y1=l1sin⁡θ1\\begin{aligned} &amp;x_1=l_1\\cos\\theta_1\\\\ &amp;y_1=l_1\\sin\\theta_1 \\end{aligned}​x1​=l1​cosθ1​y1​=l1​sinθ1​​ 第二个连杆XXX方向和YYY方向的坐标为： x2=l1cos⁡θ1+l2cos⁡(θ1+θ2)y2=l1sin⁡θ1+l2sin⁡(θ1+θ2)\\begin{aligned} &amp;x_2=l_1\\cos\\theta_1+l_2\\cos(\\theta_1+\\theta_2)\\\\ &amp;y_2=l_1\\sin\\theta_1+l_2\\sin(\\theta_1+\\theta_2) \\end{aligned}​x2​=l1​cosθ1​+l2​cos(θ1​+θ2​)y2​=l1​sinθ1​+l2​sin(θ1​+θ2​)​ 第一个连杆XXX方向和YYY方向的速度（对时间求导）为： x˙1=−l1sin⁡θ1 θ1˙y˙1=l1cos⁡θ1 θ1˙\\begin{aligned} &amp;\\dot{x}_1=-l_1\\sin\\theta_1\\,\\dot{\\theta_1}\\\\ &amp;\\dot{y}_1=l_1\\cos\\theta_1\\,\\dot{\\theta_1} \\end{aligned}​x˙1​=−l1​sinθ1​θ1​˙​y˙​1​=l1​cosθ1​θ1​˙​​ 第二个连杆XXX方向和YYY方向的速度（对时间求导）为： x˙2=−l1sin⁡θ1 θ1˙−l2sin⁡(θ1+θ2)(θ1˙+θ2˙)y˙2=l1cos⁡θ1 θ1˙+l2cos⁡(θ1+θ2)(θ1˙+θ2˙)\\begin{aligned} &amp;\\dot{x}_2=-l_1\\sin\\theta_1\\,\\dot{\\theta_1}-l_2\\sin(\\theta_1+\\theta_2)(\\dot{\\theta_1}+\\dot{\\theta_2})\\\\ &amp;\\dot{y}_2=l_1\\cos\\theta_1\\,\\dot{\\theta_1}+l_2\\cos(\\theta_1+\\theta_2)(\\dot{\\theta_1}+\\dot{\\theta_2}) \\end{aligned}​x˙2​=−l1​sinθ1​θ1​˙​−l2​sin(θ1​+θ2​)(θ1​˙​+θ2​˙​)y˙​2​=l1​cosθ1​θ1​˙​+l2​cos(θ1​+θ2​)(θ1​˙​+θ2​˙​)​ 第一个连杆的动能： T1=12m1(x˙12+y˙12)=12m1[(−l1sin⁡θ1 θ1˙)2+(l1cos⁡θ1 θ1˙)2]=12m1l12θ˙12\\begin{aligned} T_1&amp;=\\frac{1}{2}m_1(\\dot{x}_1^2+\\dot{y}_1^2)\\\\ &amp;=\\frac{1}{2}m_1\\left[\\left(-l_1\\sin\\theta_1\\,\\dot{\\theta_1}\\right)^2+\\left(l_1\\cos\\theta_1\\,\\dot{\\theta_1}\\right)^2\\right]\\\\ &amp;=\\frac{1}{2}m_1l_1^2\\dot{\\theta}_1^2 \\end{aligned}T1​​=21​m1​(x˙12​+y˙​12​)=21​m1​[(−l1​sinθ1​θ1​˙​)2+(l1​cosθ1​θ1​˙​)2]=21​m1​l12​θ˙12​​ 第二个连杆的动能： T2=12m2(x˙22+y˙22)=12m2{[−l1sin⁡θ1 θ1˙−l2sin⁡(θ1+θ2)(θ1˙+θ2˙)]2+[l1cos⁡θ1 θ1˙+l2cos⁡(θ1+θ2)(θ1˙+θ2˙))]2}=12m2[l12θ˙12+l22(θ˙1+θ˙2)2+2l1l2θ˙1(θ˙1+θ˙2)cos⁡θ2]\\begin{aligned} T_2&amp;=\\frac{1}{2}m_2(\\dot{x}_2^2+\\dot{y}_2^2)\\\\ &amp;=\\frac{1}{2}m_2\\Biggr\\{\\left[-l_1\\sin\\theta_1\\,\\dot{\\theta_1}-l_2\\sin(\\theta_1+\\theta_2)(\\dot{\\theta_1}+\\dot{\\theta_2})\\right]^2\\\\&amp;\\quad +\\left[l_1\\cos\\theta_1\\,\\dot{\\theta_1}+l_2\\cos(\\theta_1+\\theta_2)(\\dot{\\theta_1}+\\dot{\\theta_2}))\\right]^2\\Biggr\\}\\\\ &amp;=\\frac{1}{2}m_2\\left[l_1^2\\dot{\\theta}_1^2+l_2^2(\\dot{\\theta}_1+\\dot{\\theta}_2)^2+2l_1l_2\\dot{\\theta}_1(\\dot{\\theta}_1+\\dot{\\theta}_2)\\cos\\theta_2\\right] \\end{aligned}T2​​=21​m2​(x˙22​+y˙​22​)=21​m2​{[−l1​sinθ1​θ1​˙​−l2​sin(θ1​+θ2​)(θ1​˙​+θ2​˙​)]2+[l1​cosθ1​θ1​˙​+l2​cos(θ1​+θ2​)(θ1​˙​+θ2​˙​))]2}=21​m2​[l12​θ˙12​+l22​(θ˙1​+θ˙2​)2+2l1​l2​θ˙1​(θ˙1​+θ˙2​)cosθ2​]​ 由于不考虑重力、摩擦力和干扰，于是系统的总能量就是两个动能之和，记作LLL。 L=T1+T2=12m1l12θ˙12+12m2[l12θ˙12+l22(θ˙1+θ˙2)2+2l1l2θ˙1(θ˙1+θ˙2)cos⁡θ2]=12m1l12θ˙12+12m2l12θ˙12+12m2l22θ˙12+m2l22θ˙1θ˙2+12m2l22θ˙22+m2l1l2(θ˙12+θ˙1θ˙2)cos⁡θ2\\begin{aligned} L&amp;=T_1+T_2\\\\ &amp;=\\frac{1}{2}m_1l_1^2\\dot{\\theta}_1^2+\\frac{1}{2}m_2\\left[l_1^2\\dot{\\theta}_1^2+l_2^2(\\dot{\\theta}_1+\\dot{\\theta}_2)^2+2l_1l_2\\dot{\\theta}_1(\\dot{\\theta}_1+\\dot{\\theta}_2)\\cos\\theta_2\\right]\\\\ &amp;=\\frac{1}{2}m_1l_1^2\\dot{\\theta}_1^2+\\frac{1}{2}m_2l_1^2\\dot{\\theta}_1^2+\\frac{1}{2}m_2l_2^2\\dot{\\theta}_1^2+m_2l_2^2\\dot{\\theta}_1\\dot{\\theta}_2+\\frac{1}{2}m_2l_2^2\\dot{\\theta}_2^2+m_2l_1l_2(\\dot{\\theta}_1^2+\\dot{\\theta}_1\\dot{\\theta}_2)\\cos\\theta_2 \\end{aligned}L​=T1​+T2​=21​m1​l12​θ˙12​+21​m2​[l12​θ˙12​+l22​(θ˙1​+θ˙2​)2+2l1​l2​θ˙1​(θ˙1​+θ˙2​)cosθ2​]=21​m1​l12​θ˙12​+21​m2​l12​θ˙12​+21​m2​l22​θ˙12​+m2​l22​θ˙1​θ˙2​+21​m2​l22​θ˙22​+m2​l1​l2​(θ˙12​+θ˙1​θ˙2​)cosθ2​​ 机器人在连杆1和连杆2的驱动关节力矩分别是τ1\\tau_1τ1​和τ2\\tau_2τ2​，利用拉格朗日公式有： ddt(∂L∂θ1˙)−∂L∂θ1=τ1ddt(∂L∂θ2˙)−∂L∂θ2=τ2\\begin{aligned} &amp;\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\theta_1}}\\right)-\\frac{\\partial L}{\\partial \\theta_1}=\\tau_1\\\\ &amp;\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\theta_2}}\\right)-\\frac{\\partial L}{\\partial \\theta_2}=\\tau_2 \\end{aligned}​dtd​(∂θ1​˙​∂L​)−∂θ1​∂L​=τ1​dtd​(∂θ2​˙​∂L​)−∂θ2​∂L​=τ2​​ 代入上面的公式有： ddt(∂L∂θ1˙)=m1l12θ1¨+m2l12θ¨1+m2l22θ¨1+m2l22θ¨2+2m2l1l2cos⁡θ2 θ¨1−2m2l1l2sin⁡θ2 θ˙1θ˙2+m2l1l2cos⁡θ2 θ¨2−m2l1l2sin⁡θ2 θ˙22\\begin{aligned} \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\theta_1}}\\right)=&amp;m_1l_1^2\\ddot{\\theta_1}+m_2l_1^2\\ddot{\\theta}_1+m_2l_2^2\\ddot{\\theta}_1+m_2l_2^2\\ddot{\\theta}_2\\\\&amp;+2m_2l_1l_2\\cos\\theta_2\\,\\ddot{\\theta}_1-2m_2l_1l_2\\sin\\theta_2\\,\\dot{\\theta}_1\\dot{\\theta}_2\\\\&amp;+m_2l_1l_2\\cos\\theta_2\\,\\ddot{\\theta}_2-m_2l_1l_2\\sin\\theta_2\\,\\dot{\\theta}_2^2\\\\ \\end{aligned}dtd​(∂θ1​˙​∂L​)=​m1​l12​θ1​¨​+m2​l12​θ¨1​+m2​l22​θ¨1​+m2​l22​θ¨2​+2m2​l1​l2​cosθ2​θ¨1​−2m2​l1​l2​sinθ2​θ˙1​θ˙2​+m2​l1​l2​cosθ2​θ¨2​−m2​l1​l2​sinθ2​θ˙22​​ ddt(∂L∂θ2˙)=m2l22θ¨1+m2l22θ¨2+m2l1l2cos⁡θ2 θ¨1−m2l1l2sin⁡θ2 θ˙1θ˙2\\begin{aligned} \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\theta_2}}\\right)=&amp;m_2l_2^2\\ddot{\\theta}_1+m_2l_2^2\\ddot{\\theta}_2+m_2l_1l_2\\cos\\theta_2\\,\\ddot{\\theta}_1\\\\&amp;-m_2l_1l_2\\sin\\theta_2\\,\\dot{\\theta}_1\\dot{\\theta}_2\\\\ \\end{aligned}dtd​(∂θ2​˙​∂L​)=​m2​l22​θ¨1​+m2​l22​θ¨2​+m2​l1​l2​cosθ2​θ¨1​−m2​l1​l2​sinθ2​θ˙1​θ˙2​​ ∂L∂θ1=0\\begin{aligned} \\frac{\\partial L}{\\partial \\theta_1}=0 \\end{aligned}∂θ1​∂L​=0​ ∂L∂θ2=m2l1l2θ˙12sin⁡θ2+m2l1l2θ˙1θ˙2sin⁡θ2\\begin{aligned} \\frac{\\partial L}{\\partial \\theta_2}=m_2l_1l_2\\dot{\\theta}_1^2\\sin\\theta_2+m_2l_1l_2\\dot{\\theta}_1\\dot{\\theta}_2\\sin\\theta_2 \\end{aligned}∂θ2​∂L​=m2​l1​l2​θ˙12​sinθ2​+m2​l1​l2​θ˙1​θ˙2​sinθ2​​ 整理以后我们就有： (m1l12+m2l12+m2l22+2m2l1l2cos⁡θ2)θ¨1+(m2l1l2cos⁡θ2+m2l22)θ¨2−2m2l1l2sin⁡θ2θ˙1θ˙2−m2l1l2sin⁡θ2θ˙22=τ1\\begin{aligned} &amp;(m_1l_1^2+m_2l_1^2+m_2l_2^2+2m_2l_1l_2\\cos\\theta_2)\\ddot{\\theta}_1+(m_2l_1l_2\\cos\\theta_2+m_2l_2^2)\\ddot{\\theta}_2\\\\&amp;-2m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_1\\dot{\\theta}_2-m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_2^2=\\tau_1 \\end{aligned}​(m1​l12​+m2​l12​+m2​l22​+2m2​l1​l2​cosθ2​)θ¨1​+(m2​l1​l2​cosθ2​+m2​l22​)θ¨2​−2m2​l1​l2​sinθ2​θ˙1​θ˙2​−m2​l1​l2​sinθ2​θ˙22​=τ1​​ (m2l1l2cos⁡θ2+m2l22)θ¨1+m2l22θ¨2+m2l1l2sin⁡θ2θ˙12=τ2\\begin{aligned} &amp;(m_2l_1l_2\\cos\\theta_2+m_2l_2^2)\\ddot{\\theta}_1+m_2l_2^2\\ddot{\\theta}_2+m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_1^2=\\tau_2 \\end{aligned}​(m2​l1​l2​cosθ2​+m2​l22​)θ¨1​+m2​l22​θ¨2​+m2​l1​l2​sinθ2​θ˙12​=τ2​​ 于是我们就可以写成书中的形式，描述为矩阵非常简洁的形式： D(q)q¨+C(q,q˙)q˙=τ\\begin{aligned} \\mathbf{D(q)\\ddot{q}+C(q,\\dot{q})\\dot{q}}=\\bm{\\tau} \\end{aligned}D(q)q¨​+C(q,q˙​)q˙​=τ​ 其中： D(q)=[m1l12+m2l12+m2l22+2m2l1l2cos⁡θ2m2l1l2cos⁡θ2+m2l22m2l1l2cos⁡θ2+m2l22m2l22]\\mathbf{D(q)}=\\begin{bmatrix} m_1l_1^2+m_2l_1^2+m_2l_2^2+2m_2l_1l_2\\cos\\theta_2 &amp; m_2l_1l_2\\cos\\theta_2+m_2l_2^2\\\\ m_2l_1l_2\\cos\\theta_2+m_2l_2^2 &amp; m_2l_2^2 \\end{bmatrix}D(q)=[m1​l12​+m2​l12​+m2​l22​+2m2​l1​l2​cosθ2​m2​l1​l2​cosθ2​+m2​l22​​m2​l1​l2​cosθ2​+m2​l22​m2​l22​​] C(q,q˙)=[−m2l1l2sin⁡θ2θ˙2−m2l1l2sin⁡θ2θ˙1−m2l1l2sin⁡θ2θ˙2m2l1l2sin⁡θ2θ˙10]\\mathbf{C(q,\\dot{q})}=\\begin{bmatrix} -m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_2 &amp; -m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_1-m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_2\\\\ m_2l_1l_2\\sin\\theta_2\\dot{\\theta}_1 &amp; 0 \\end{bmatrix}C(q,q˙​)=[−m2​l1​l2​sinθ2​θ˙2​m2​l1​l2​sinθ2​θ˙1​​−m2​l1​l2​sinθ2​θ˙1​−m2​l1​l2​sinθ2​θ˙2​0​] q=[θ1θ2]q˙=[θ˙1θ˙2]τ=[τ1τ2]\\mathbf{q}=\\begin{bmatrix} \\theta_1\\\\ \\theta_2 \\end{bmatrix}\\quad \\dot{\\mathbf{q}}=\\begin{bmatrix} \\dot{\\theta}_1\\\\ \\dot{\\theta}_2 \\end{bmatrix}\\quad \\bm{\\tau}=\\begin{bmatrix} {\\tau}_1\\\\ {\\tau}_2 \\end{bmatrix}q=[θ1​θ2​​]q˙​=[θ˙1​θ˙2​​]τ=[τ1​τ2​​] 这也就解释了开头书中的公式： Image 其中 p1=m1l12+m2l12p2=m2l22p2=m2l1l2\\begin{aligned} p_1&amp;=m_1l_1^2+m_2l_1^2\\\\ p_2&amp;=m_2l_2^2\\\\ p_2&amp;=m_2l_1l_2 \\end{aligned}p1​p2​p2​​=m1​l12​+m2​l12​=m2​l22​=m2​l1​l2​​","tags":["机器人控制"],"categories":["机器人"]},{"title":"关于我为什么开通博客","path":"/2023/04/02/关于我为什么开通博客/","content":"我第一次知道有博客这种东西应该是本科查资料的时候，经常就查到一些大佬自己建的网站，炫酷的页面，舒适的排版，当时就觉得建立博客是一件很酷的事。但那时候并没有想到要建立自己的网站。 其实我本科乃至以前都是不爱做笔记的，每次开学的时候我都信誓旦旦地买了好几本笔记本，下定决心要记上几本。然而有几点原因让我始终不能坚持下去：一来一开始写得工工整整，但后面逐渐潦草，消磨了我写笔记的耐心；二来整理笔记于我而言实在太浪费时间，我的记忆力还算可以的，上课听懂的东西再做整理我觉得不如多看看书做点练习；三来写笔记需要长期的坚持，我那时课业也多，没办法抽出额外的时间坚持(好吧~可能也是借口)。 说来也巧，大一的时候机缘巧合在CSDN注册了一个账号（账号名就是这个网站的名字“小林up”），原因是当时写作业要查资料就知道了这个平台，但是那时只是看没有自己写。 我真正开始有意识第记录博客是大二的时候，当时加入了学校的一个科创团队，韩队长教我们记录的重要性，他就经常在知乎上发布文章，记录他踩过的坑，构建自己的知识体系。在他的影响下，我也开始用电脑记录一些自己的东西，不过我的第一个平台还是前面提到的CSDN，还记得当时写的第一篇是关于MATLAB desolve函数的解读，但是当时我并没有养成写博客整理笔记的习惯。 真正让我迷上写博客的是大四的时候，真是后知后觉了哈哈，当时做的课程设计要设计PCB电路板，就把自己设计电路板踩过的坑给记录放在了CSDN，没想到以外收到了一波点赞和收藏，我突然感觉了一点成就感，很多自媒体的博主在他们视频的末尾都说：“你们的点赞和收藏就是对我最大的支持。”想来真是一点没错，于是大四的时候觉得能记录的就记录一下，没想到那年倒是写了100来篇。到现在已经破200篇了。我开始逐渐对写博客这件事形成了习惯。 读研究生的时候，在网上认识了好友小曦。小曦推荐我一本小说叫《众神世界》，虽然主角成长得很变态，但是不妨碍里面还是有很好的方法论。我很认可也很喜欢里面所说的费曼技巧的本质： 大家都以为，学习是看书，是记忆，是听讲，最多加上反复看或听，不，这只是学习的一部分，我把这部分命名为“输入”，也就是从外界吸收知识。我们做题，是不是由内而外利用知识？费曼技巧中的“教”，是不是也一种由内而外？这个过程，我称其为“输出”。学习的本质，就是输入加输出的过程，输入和输出构成完整的学习体系！ 我们在“输入”的时候，也就是听、看的时候，是“别人的东西”进入到我们的大脑里，我们如果不思考，不去动用那些“别人的东西”，为了节省精力，大脑会欺骗我们，让我们假装理解了。这样，仅仅是知道一个‘新名词’而已，离“理解”差十万八千里！当必须要输出的时候，我们的大脑会把需要的知识进行“整理”“挑选”“组合”“排列”“对比”“联系”等等一系列复杂的处理，如果我们输出不了，卡住了，是什么原因？没理解！只有理解了，才能输出。不理解怎么办？费曼技巧会让我们重新学习，重新理解。 虽然在CSDN上记录了很多，不过秉持着费曼技巧的思想，我觉得自己还是记录一些比较成体系的内容，况且倒腾一个个人博客也是能学会很多东西的，我在写博客的过程中也是丰富自己的认识，更体会到终身学习的重要性。 我希望，自己能做个持续输出、精进自己的长期主义者，可能更新不是很快，因为现在是研究生也有自己的日常工作，不过我还是尽量每周更新至少一篇吧。 于是啊于是，就有了你现在看到的这篇博客。","tags":["随笔"],"categories":["随笔"]},{"path":"/friends/index.html","content":"友链 xaoxuuFivyex's Blog修曦鳄鱼的博客 朋友圈"},{"path":"/notes/index.html","content":"写在前面 欢迎来到我的笔记小站！ 终生学习的重要性不言而喻，培根说过：To live is to learn, to learn is not to live。意思是【活着就要学习，学习不是为了活着】。 所以在有生之年，我将把我想学的知识系统地记录在这里，也希望能对你有帮助。"},{"title":"计算机图形学基础","path":"/notes/计算机图形学/计算机图形学基础.html","content":"1 Transformation Matrix-变换矩阵 另外要注意的是： 运动的合成根据的是矩阵左乘规则，因为参考坐标系始终是固定坐标系。 下面的齐次坐标是等价的： (x,y,z,1)≜(kx,ky,kz,k!=0)(x, y, z, 1)\\triangleq(k x, k y, k z, k !=0) (x,y,z,1)≜(kx,ky,kz,k!=0) 例子：(1,0,0,1)(1,0,0,1)(1,0,0,1) 和(2,0,0,2)(2,0,0,2)(2,0,0,2) 都表示(1,0,0)(1,0,0)(1,0,0) 2 Viewing-观测 观测主要解决的问题是如何把物体的三维“模型”变成我们在屏幕所看到的二维“图片”，我们在计算机看到实体模型可以分成这样几步： 物体空间如何经过一系列变换转化到屏幕上 相机变换(camera transformation)或眼变换(eye transformation)：想象把相机放在任意一个位置来观测物体，我们首先就要把物体的世界坐标转换为相机坐标，这一步称为相机变换或眼变换。 投影变换(projection transformation)：相机把物体拍成照片本质是从三维的相机坐标转化为二维的平面坐标，这一步称为投影变换。投影可以分为正射投影和透视投影。 视口变换(viewport transformation)或窗口变换(windowing transformation)：相机拍成的图片最后是要显示在屏幕上，我们需要把二维的图片坐标再转换为电脑屏幕的像素坐标，这一步称为视口变换或窗口变换。 下面这个照相的类比非常地生动形象。 观测的形象解释 2.1 Viewport Transformation-视口变换 一般来说，我们规定相机沿着−z-\\mathbf{z}−z方向，在观测过程中为了简化会使用canonical view volume(CCV)：它是一个正方体，xxx,yyy,zzz坐标都位于−1-1−1到111之间，也即(x,y,z)∈[−1,1]3(x,y,z)\\in[-1,1]^3(x,y,z)∈[−1,1]3，我们将x=−1x=-1x=−1投影到电脑屏幕的左侧，将x=+1x=+1x=+1投影到屏幕的右侧，将y=−1y=-1y=−1投影到屏幕的底部，将y=+1y=+1y=+1投影到屏幕的顶部。 canonical view volume(CCV) 如果我们定义屏幕每个像素的长和宽为1，最小的像素中心坐标是(0,0)(0,0)(0,0)，则图像的中心到其边界为0.50.50.5，如果屏幕上的像素总长度为nxn_xnx​，总宽度为nyn_yny​，那么我们可以将canonical view volume(CCV)的xoy\\mathbf{xoy}xoy平面的方形[−1,1]2[-1,1]^2[−1,1]2映射为长方形[−0.5,nx−0.5]×[−0.5,ny−0.5][-0.5,n_x-0.5]\\times[-0.5,n_y-0.5][−0.5,nx​−0.5]×[−0.5,ny​−0.5]。 注意我们现在假设所有的线都在CCV正方体里，后面这个假设将在讲裁剪的时候放松这个条件。 对于视口变换，我们需要想把CCV正方体的xoy\\mathbf{xoy}xoy平面进行放缩然后将原点平移到屏幕的左下角（CCV的原点在xoy\\mathbf{xoy}xoy正方形的正中心），其可以写作一个二维的变换【这里相当于计算上面的线性映射：−1→−0.5,1→nx−0.5(-1\\rightarrow -0.5,1\\rightarrow n_x-0.5(−1→−0.5,1→nx​−0.5(或ny−0.5)n_y-0.5)ny​−0.5)】： [xscreen yscreen 1]=[nx20nx−120ny2ny−12001][xcanonical ycanonical 1]\\begin{bmatrix} x_{\\text {screen }} \\\\ y_{\\text {screen }} \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} \\frac{n_{x}}{2} &amp; 0 &amp; \\frac{n_{x}-1}{2} \\\\ 0 &amp; \\frac{n_{y}}{2} &amp; \\frac{n_{y}-1}{2} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\begin{bmatrix} x_{\\text {canonical }} \\\\ y_{\\text {canonical }} \\\\ 1 \\end{bmatrix}⎣⎢⎡​xscreen ​yscreen ​1​⎦⎥⎤​=⎣⎢⎡​2nx​​00​02ny​​0​2nx​−1​2ny​−1​1​⎦⎥⎤​⎣⎢⎡​xcanonical ​ycanonical ​1​⎦⎥⎤​ 这里忽略了z\\mathbf{z}z轴的坐标，因为投影最终和zzz坐标无关，这里我们可以扩充矩阵（尽管在这里没有用）： Mvp=[nx200nx−120ny20ny−1200100001]\\mathbf{M}_{\\mathrm{vp}}=\\begin{bmatrix} \\frac{n_{x}}{2} &amp; 0 &amp; 0 &amp; \\frac{n_{x}-1}{2} \\\\ 0 &amp; \\frac{n_{y}}{2} &amp; 0 &amp; \\frac{n_{y}-1}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}Mvp​=⎣⎢⎢⎢⎡​2nx​​000​02ny​​00​0010​2nx​−1​2ny​−1​01​⎦⎥⎥⎥⎤​ 2.2 Orthographic Projection Transformation-正射变换 我们通常想把在渲染某个空间区域的几何元素而不是CCV，我们要调整我们的坐标轴的方向来实现正射变换，让坐标轴的−z-\\mathbf{z}−z轴对着物体，让y\\mathbf{y}y轴朝上，x\\mathbf{x}x轴按照右手定则定义。我们看到的view volume是一个[l,r]×[b,t]×[f,n][l,r]\\times[b,t]\\times[f,n][l,r]×[b,t]×[f,n]的box。 正射变换 关于l,r,b,y,f,nl,r,b,y,f,nl,r,b,y,f,n的物理含义可以看下面的表格： 符号的物理含义 plane meaning plane meaning x=lx=lx=l left plane x=rx=rx=r right plane y=by=by=b bottom plane y=ty=ty=t top plane z=nz=nz=n near plane z=fz=fz=f far plane 我们同样可以写出变换矩阵把这个box映射为CCV（参考原书公式的6.7，英文原版132页）,变换的好处是简化数字在−1-1−1到111之间，方便后续计算： Morth =[2r−l00002t−b00002n−f00001][100−r+l2010−t+b2001−n+f20001]=[2r−l00−r+lr−l02t−b0−t+bt−b002n−f−n+fn−f0001]\\begin{aligned}\\mathbf{M}_{\\text {orth }}&amp;=\\left[\\begin{array}{cccc} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2} \\\\ 0 &amp; 1 &amp; 0 &amp; -\\frac{t+b}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]\\\\&amp;=\\begin{bmatrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\frac{r+l}{r-l} \\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; -\\frac{t+b}{t-b} \\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; -\\frac{n+f}{n-f} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\end{aligned}Morth ​​=⎣⎢⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎥⎥⎥⎤​⎣⎢⎢⎢⎡​1000​0100​0010​−2r+l​−2t+b​−2n+f​1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​−r−lr+l​−t−bt+b​−n−fn+f​1​⎦⎥⎥⎥⎤​​ 现在我们可以转换视角中任意看到的点(x,y,z)(x,y,z)(x,y,z)在像素上看到的位置(xpixel,ypixel,zcanonical)(x_{pixel},y_{pixel},z_{canonical})(xpixel​,ypixel​,zcanonical​) [xpixel ypixel zcanonical 1]=(MvpMorth )[xyz1]\\left[\\begin{array}{c} x_{\\text {pixel }} \\\\ y_{\\text {pixel }} \\\\ z_{\\text {canonical }} \\\\ 1 \\end{array}\\right]=\\left(\\mathbf{M}_{\\mathrm{vp}} \\mathbf{M}_{\\text {orth }}\\right)\\left[\\begin{array}{c} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right]⎣⎢⎢⎢⎡​xpixel ​ypixel ​zcanonical ​1​⎦⎥⎥⎥⎤​=(Mvp​Morth ​)⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​ CCV坐标变换至屏幕坐标直线算法流程： CCV变换至屏幕坐标直线 z\\mathbf{z}z坐标的范围是[−1,1][-1,1][−1,1]，现在我们还没有用到，这将在z-buffer算法时很有用。 2.3 Camera Transformation-相机变换 当我们需要改变3D视角和观测的方向时，我们需要重新定义观测者的位置和方向（改变相机的放置位置）。可以定义相机坐标系，我们期望的相机的朝向可以由两个向量g\\mathbf{g}g和向量t\\mathbf{t}t来定义，以及一个点e\\mathbf{e}e来表示。 e\\mathbf{e}e：相机位置 g\\mathbf{g}g：观测方向 t\\mathbf{t}t：上视方向 于是我们可以根据上面所说的向量和电定义我们的相机坐标系uvw\\mathbf{uvw}uvw（世界坐标系是xyz\\mathbf{xyz}xyz），其中坐标系的原点就是e\\mathbf{e}e，v\\mathbf{v}v轴和t\\mathbf{t}t矢量方向相同，w\\mathbf{w}w轴和−g-\\mathbf{g}−g矢量方向相同，u\\mathbf{u}u轴根据右手定则确定。 w=−g∥g∥u=t×w∥t×w∥v=w×u\\begin{aligned} \\mathbf{w} &amp; = -\\frac{\\mathbf{g}}{\\|\\mathbf{g}\\|} \\\\ \\mathbf{u} &amp; = \\frac{\\mathbf{t} \\times \\mathbf{w}}{\\|\\mathbf{t} \\times \\mathbf{w}\\|} \\\\ \\mathbf{v} &amp; = \\mathbf{w} \\times \\mathbf{u} \\end{aligned}wuv​=−∥g∥g​=∥t×w∥t×w​=w×u​ 相机坐标系 接下来我们会把世界坐标系的点坐标转换到相机坐标系中。我们可以把变换矩阵分解为两步，先平移再旋转。 由于将坐标系uvw\\mathbf{uvw}uvw转换为坐标系xyz\\mathbf{xyz}xyz的变换矩阵可以看做是 Mcam−1=[uvwe0001]\\mathbf{M}_{\\mathrm{cam}}^{-1}=\\left[\\begin{array}{cccc} \\mathbf{u} &amp; \\mathbf{v} &amp; \\mathbf{w} &amp; \\mathbf{e} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]Mcam−1​=[u0​v0​w0​e1​] 相机坐标系是要将坐标系xyz\\mathbf{xyz}xyz转换到坐标系uvw\\mathbf{uvw}uvw，于是这等价于对矩阵求一个逆。 Mcam=[uvwe0001]−1=[xuyuzu0xvyvzv0xwywzw00001][100−xe010−ye001−ze0001]\\mathbf{M}_{\\mathrm{cam}}=\\left[\\begin{array}{cccc} \\mathbf{u} &amp; \\mathbf{v} &amp; \\mathbf{w} &amp; \\mathbf{e} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]^{-1}=\\left[\\begin{array}{cccc} x_{u} &amp; y_{u} &amp; z_{u} &amp; 0 \\\\ x_{v} &amp; y_{v} &amp; z_{v} &amp; 0 \\\\ x_{w} &amp; y_{w} &amp; z_{w} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; -x_{e} \\\\ 0 &amp; 1 &amp; 0 &amp; -y_{e} \\\\ 0 &amp; 0 &amp; 1 &amp; -z_{e} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]Mcam​=[u0​v0​w0​e1​]−1=⎣⎢⎢⎢⎡​xu​xv​xw​0​yu​yv​yw​0​zu​zv​zw​0​0001​⎦⎥⎥⎥⎤​⎣⎢⎢⎢⎡​1000​0100​0010​−xe​−ye​−ze​1​⎦⎥⎥⎥⎤​ 世界坐标正式投影变换至屏幕坐标画直线算法流程： 世界坐标正式投影变换至屏幕坐标画直线 2.4 Perspective Projective Transformations-透视变换 投影变换符合我们的视觉直观，主要体现在有近大远小的特性，平行线相交于一点。在实际的计算机图形中用得更多。 2D投影变换 如上图所示，我们从视点e\\mathbf{e}e沿着g\\mathbf{g}g方向看，看到的实际的点的高度为yyy，反映在观察平面上高度为ysy_sys​，观察平面距离视点为ddd，实际的点距离视点为zzz，根据简单的相似三角形的关系，我们有（这里我们认为zzz是距离，为正数，而不是坐标意义下的负数）： ys=dzyy_{s}=\\frac{d}{z} y ys​=zd​y 虎书里还提到了线性有理变换，这里把变换矩阵简单写一下（感兴趣可以直接看虎书） [x~y~z~w~]=[a1b1c1d1a2b2c2d2a3b3c3d3efgh][xyz1]\\left[\\begin{array}{c} \\tilde{x} \\\\ \\tilde{y} \\\\ \\tilde{z} \\\\ \\tilde{w} \\end{array}\\right]=\\left[\\begin{array}{cccc} a_{1} &amp; b_{1} &amp; c_{1} &amp; d_{1} \\\\ a_{2} &amp; b_{2} &amp; c_{2} &amp; d_{2} \\\\ a_{3} &amp; b_{3} &amp; c_{3} &amp; d_{3} \\\\ e &amp; f &amp; g &amp; h \\end{array}\\right]\\left[\\begin{array}{c} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right]⎣⎢⎢⎢⎡​x~y~​z~w~​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​a1​a2​a3​e​b1​b2​b3​f​c1​c2​c3​g​d1​d2​d3​h​⎦⎥⎥⎥⎤​⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​ (x′,y′,z′)=(x~/w~,y~/w~,z~/w~)\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}\\right)=(\\tilde{x} / \\tilde{w}, \\tilde{y} / \\tilde{w}, \\tilde{z} / \\tilde{w}) (x′,y′,z′)=(x~/w~,y~​/w~,z~/w~) 上面的第二个公式刚好使用了[1-Transformation Matrix-变换]中注意的第二点：齐次坐标的等价性。使用上述的变换可以进行下面的操作： 前面我们已经讲了二维的情况。但是我们实际要处理的是三维的情况。经过投影变换就好像把一个棱台给变成了一个轴平行的box。这将方便我们使用正交投影变换矩阵变成CCV。 3D投影变换 这里我们就搬出之前在[Camera Transformation-相机变换]所建立的坐标系，我们依然使用z=nz=nz=n近端平面和z=fz=fz=f远端平面，并使用z=nz=nz=n近端平面作为观察平面。需要注意的是，上面的nnn和zzz在坐标系定义下都是小于000的。对于投影变换后的xsx_sxs​和ysy_sys​，类似前面二维情况： ys=nzyxs=nzxy_{s}=\\frac{n}{z} y\\quad x_{s}=\\frac{n}{z} x ys​=zn​yxs​=zn​x 我们可以整理成矩阵的形式： (xyz1)⇒(nx/zny/zunknown1)≜(nxnyunknownz)\\begin{pmatrix} x\\\\y\\\\z\\\\1 \\end{pmatrix}\\Rightarrow\\begin{pmatrix} nx/z\\ y/z\\\\\\mathrm{unknown}\\\\1 \\end{pmatrix}\\triangleq\\begin{pmatrix} nx\\ y\\\\\\mathrm{unknown}\\\\z \\end{pmatrix}⎝⎜⎜⎜⎛​xyz1​⎠⎟⎟⎟⎞​⇒⎝⎜⎜⎜⎛​nx/zny/zunknown1​⎠⎟⎟⎟⎞​≜⎝⎜⎜⎜⎛​nxnyunknownz​⎠⎟⎟⎟⎞​ 于是我们所要求的投影变换矩阵满足： P(xyz1)=(nxnyunknownz)⇒P=(n0000n00????0010)\\mathbf{P}\\begin{pmatrix} x\\\\y\\\\z\\\\1 \\end{pmatrix}=\\begin{pmatrix} nx\\ y\\\\\\mathrm{unknown}\\\\z \\end{pmatrix}\\Rightarrow \\mathbf{P} =\\left(\\begin{array}{cccc} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ ? &amp; ? &amp; ? &amp; ? \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{array}\\right)P⎝⎜⎜⎜⎛​xyz1​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​nxnyunknownz​⎠⎟⎟⎟⎞​⇒P=⎝⎜⎜⎜⎛​n0?0​0n?0​00?1​00?0​⎠⎟⎟⎟⎞​ 那么zsz_{s}zs​是多少呢？对投影变换我们注意到： 近端平面z=nz=nz=n的点映射以后点不发生变化。 远端平面z=fz=fz=f的点映射以后z坐标不变。 根据第(1)点：近端平面z=nz=nz=n的点映射以后点不发生变化。我们有： P(xyn1)=(xyn1)≜(nxnyn21)\\mathbf{P}\\begin{pmatrix} x\\\\y\\ \\\\1 \\end{pmatrix}=\\begin{pmatrix} x\\\\y\\ \\\\1 \\end{pmatrix} \\triangleq\\begin{pmatrix} nx\\ y\\ ^2\\\\1 \\end{pmatrix}P⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​≜⎝⎜⎜⎜⎛​nxnyn21​⎠⎟⎟⎟⎞​ 所以P\\mathbf{P}P的第三行形式为(0 0 A B)\\begin{pmatrix} 0\\,0\\,A\\,B \\end{pmatrix}(00AB​)，前两个元素为0是因为该齐次坐标的zzz坐标为n2n^2n2，和x,yx,yx,y的取值无关。我们单独拿出第三行和齐次坐标相乘有： (00AB)(xyn1)=n2⇒An+B=n2\\begin{pmatrix} 0 &amp; 0 &amp; A &amp; B \\end{pmatrix}\\begin{pmatrix} x \\\\ y \\\\ n \\\\ 1 \\end{pmatrix}=n^{2}\\Rightarrow An+B=n^2(0​0​A​B​)⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​=n2⇒An+B=n2 根据第(2)点：远端平面z=fz=fz=f的点映射以后z坐标不变。我们有： (00f1)⇒(00f1)≜(00f2f)⇒Af+B=f2\\left(\\begin{array}{l} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{array}\\right) \\Rightarrow\\left(\\begin{array}{l} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{array}\\right)\\triangleq\\left(\\begin{array}{c} 0 \\\\ 0 \\\\ f^{2} \\\\ f \\end{array}\\right)\\Rightarrow Af+B=f^2⎝⎜⎜⎜⎛​00f1​⎠⎟⎟⎟⎞​⇒⎝⎜⎜⎜⎛​00f1​⎠⎟⎟⎟⎞​≜⎝⎜⎜⎜⎛​00f2f​⎠⎟⎟⎟⎞​⇒Af+B=f2 于是我们有： {An+B=n2Af+B=f2⇒{A=n+fB=−nf\\left\\{\\begin{aligned} &amp;An+B=n^2\\\\ &amp;Af+B=f^2 \\end{aligned}\\right.\\quad\\Rightarrow\\quad\\left\\{\\begin{aligned} &amp;A=n+f\\\\ &amp;B=-nf \\end{aligned}\\right.{​An+B=n2Af+B=f2​⇒{​A=n+fB=−nf​ 这样我们就确定了投影变换的变换矩阵： P=[n0000n0000n+f−fn0010]\\mathbf{P}=\\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; n+f &amp; -f n \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}P=⎣⎢⎢⎢⎡​n000​0n00​00n+f1​00−fn0​⎦⎥⎥⎥⎤​ 经过投影变换最终我们看到坐标发生了如下的变化： P[xyz1]=[nxny(n+f)z−fnz]≜[nxznyzn+f−fnz1]\\mathbf{P}\\left[\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right]=\\left[\\begin{array}{c} n x \\\\ n y \\\\ (n+f) z-f n \\\\ z \\end{array}\\right] \\triangleq\\left[\\begin{array}{c} \\frac{n x}{z} \\\\ \\frac{n y}{z} \\\\ n+f-\\frac{f n}{z} \\\\ 1 \\end{array}\\right]P⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​nxny(n+f)z−fnz​⎦⎥⎥⎥⎤​≜⎣⎢⎢⎢⎡​znx​zny​n+f−zfn​1​⎦⎥⎥⎥⎤​ 有时候我们想把屏幕坐标变换回世界坐标，这时候我们就需要用到P\\mathbf{P}P的逆矩阵： P−1=[1n00001n00000100−1fnn+ffn]≜[f0000f00000fn00−1n+f]\\mathbf{P}^{-1}=\\left[\\begin{array}{cccc} \\frac{1}{n} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{1}{n} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; -\\frac{1}{f n} &amp; \\frac{n+f}{f n} \\end{array}\\right]\\triangleq\\left[\\begin{array}{cccc} f &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; f &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; f n \\\\ 0 &amp; 0 &amp; -1 &amp; n+f \\end{array}\\right]P−1=⎣⎢⎢⎢⎡​n1​000​0n1​00​000−fn1​​001fnn+f​​⎦⎥⎥⎥⎤​≜⎣⎢⎢⎢⎡​f000​0f00​000−1​00fnn+f​⎦⎥⎥⎥⎤​ 完整的透视变换包括了正视变换和投影变换的组合，先处理近大远小的投影变换为box，然后把box变回一个CCV。 Mper=MorthP=[2nr−l0l+rl−r002nt−bb+tb−t000f+nn−f2fnf−n0010]\\mathbf{M}_{\\mathrm{per}}=\\mathbf{M}_{\\mathrm{orth}} \\mathbf{P}=\\left[\\begin{array}{cccc} \\frac{2 n}{r-l} &amp; 0 &amp; \\frac{l+r}{l-r} &amp; 0 \\\\ 0 &amp; \\frac{2 n}{t-b} &amp; \\frac{b+t}{b-t} &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{f+n}{n-f} &amp; \\frac{2 f n}{f-n} \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{array}\\right]Mper​=Morth​P=⎣⎢⎢⎢⎡​r−l2n​000​0t−b2n​00​l−rl+r​b−tb+t​n−ff+n​1​00f−n2fn​0​⎦⎥⎥⎥⎤​ 在OpenGL中，这一矩阵的定义可能不一样： MOpenGL =[2∣n∣r−l0r+lr−l002∣n∣t−bt+bt−b000∣n∣+∣f∣∣n∣−∣f∣2∣f∣∣n∣∣n∣−∣f∣00−10]\\mathbf{M}_{\\text {OpenGL }}=\\left[\\begin{array}{cccc} \\frac{2|n|}{r-l} &amp; 0 &amp; \\frac{r+l}{r-l} &amp; 0 \\\\ 0 &amp; \\frac{2|n|}{t-b} &amp; \\frac{t+b}{t-b} &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{|n|+|f|}{|n|-|f|} &amp; \\frac{2|f||n|}{|n|-|f|} \\\\ 0 &amp; 0 &amp; -1 &amp; 0 \\end{array}\\right]MOpenGL ​=⎣⎢⎢⎢⎢⎡​r−l2∣n∣​000​0t−b2∣n∣​00​r−lr+l​t−bt+b​∣n∣−∣f∣∣n∣+∣f∣​−1​00∣n∣−∣f∣2∣f∣∣n∣​0​⎦⎥⎥⎥⎥⎤​ 这里我们使用了Morth\\mathbf{M}_{\\mathrm{orth}}Morth​，随之而来的问题是：Morth\\mathbf{M}_{\\mathrm{orth}}Morth​中的l,r,t,bl,r,t,bl,r,t,b这些值怎么定义呢，它们定义了我们的窗口看到的物体，由于近端平面z=nz=nz=n的xxx和yyy不变，我们这里选择了近端平面z=nz=nz=n来定义l,r,t,bl,r,t,bl,r,t,b。 我们最后来看一下从相机坐标经过透视变换到屏幕坐标的算法流程： 相机坐标经过透视变换到屏幕坐标的算法流程 2.5 Field-of-View-视场 我们通过(l,r,t,b)(l,r,t,b)(l,r,t,b)和nnn定义我们的窗口，我们可以进一步简化，如果我们屏幕的中心是原点，那么有： l=−r,b=−t.\\begin{aligned} l &amp; =-r, \\\\ b &amp; =-t . \\end{aligned}lb​=−r,=−t.​ 另外我们可以添加每个像素是正方形的约束，使得图形没有形状的畸变，我们使用的rrr和ttt一定要和水平像素数nxn_xnx​和竖直像素数nyn_yny​成比例： nxny=rt\\frac{n_{x}}{n_{y}}=\\frac{r}{t} ny​nx​​=tr​ 当nxn_xnx​和nyn_yny​被确定以后，只剩下一个自由度，我们经常使用θ\\thetaθ作为视场，下图为垂直视场，它满足关系： tan⁡θ2=t∣n∣\\tan\\frac{\\theta}{2}=\\frac{t}{|n|} tan2θ​=∣n∣t​ 垂直视场 通过确定nnn和θ\\thetaθ，我们就可以计算ttt来得到更一般的观测系统。 3 Graphics Pipeline-图形管线 渲染的第二种主要方法是逐个将对象绘制到屏幕上，也称为物体顺序渲染。与后面讲到的光线追踪不同，在光线追踪中我们逐个考虑每个像素并找到影响其颜色的对象，现在我们将逐个考虑每个几何对象并找到它可能影响的像素（说得有点拗口哈哈）。 找到图像中由几何图元占据的所有像素的过程称为光栅化，因此物体顺序渲染也可以称为光栅化渲染。执行从对象开始到更新图像像素结束的一系列操作被称为图形管线。 当然，物体顺序渲染不只有一种方法——两个非常不同的图形管线示例是用于通过OpenGL和Direct3D等API支持交互式渲染的硬件管线，以及用于电影制作的支持RenderMan等API的软件管线。硬件管线必须以足够快的速度运行，以实时响应游戏、可视化和用户界面。软件管线必须呈现最高质量的动画和视觉效果，并能适应庞大的场景，但可能需要更长的渲染时间。 图形管线可以分为四个阶段：顶点处理、光栅化、片段处理和片段混合。 几何对象通过交互应用程序或场景描述文件输入到管线中，并且始终由一组顶点描述。顶点处理阶段对顶点进行操作，然后使用这些顶点生成基本图元发送到光栅化阶段。 物体顺序渲染的工作可以分为三个阶段：光栅化、光栅化前的几何操作和光栅化后的像素操作。几何操作中最常见的操作是应用矩阵变换，将定义几何形状的点从物体空间映射到屏幕空间，以便输入到光栅化器时以像素坐标或屏幕空间表示。像素操作中最常见的操作是隐藏面消除，使离观察者更近的表面显示在离观察者更远的表面之前。 光栅化器将每个基本图元分解为一组片段(fragment)，每个片段对应于被基本图元覆盖的像素。片段处理阶段处理各个片段，然后在片段混合阶段中将每个像素对应的片段进行合并。下面是图形管线的示意图。 3.1 光栅化"}]